use async_std::path::PathBuf;
use regex::Regex;
use std::{collections::HashSet, path::Path};
use tide::{Next, Request, Response, StatusCode};

#[derive(Debug, Clone)]
pub struct NodeModules {
    root_dir: String,
    // 添加依赖跟踪
    dependencies: std::sync::Arc<parking_lot::RwLock<HashSet<String>>>,
}

impl NodeModules {
    pub fn new(root_dir: String) -> Self {
        NodeModules {
            root_dir,
            dependencies: std::sync::Arc::new(parking_lot::RwLock::new(HashSet::new())),
        }
    }

    // 检查是否是第三方模块导入
    fn is_node_module_import(&self, path: &str) -> bool {
        !path.starts_with(".") && !path.starts_with("/") && !path.starts_with("http")
    }

    // 从 node_modules 解析模块路径
    async fn resolve_module_path(&self, module_name: &str) -> Option<PathBuf> {
        let node_modules = Path::new(&self.root_dir).join("node_modules");
        let package_path = node_modules.join(module_name);

        if async_std::fs::metadata(&package_path).await.is_ok() {
            // 读取 package.json
            let package_json = package_path.join("package.json");
            if let Ok(content) = async_std::fs::read_to_string(&package_json).await {
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                    // 优先使用 module 字段，否则使用 main 字段
                    if let Some(entry) = json.get("module").or_else(|| json.get("main")) {
                        if let Some(entry_path) = entry.as_str() {
                            return Some(package_path.join(entry_path));
                        }
                    }
                }
            }
            // 如果没有找到入口文件，默认使用 index.js
            Some(package_path.join("index.js"))
        } else {
            None
        }
    }

    // 处理导入语句并收集依赖
    async fn process_imports(&self, content: String, file_path: &str) -> String {
        let import_re = Regex::new(r#"(?m)^import\s+.*?from\s+["']([^"']+)["']"#).unwrap();
        let mut result = content.clone();

        // 收集该文件的所有依赖
        let mut file_deps = HashSet::new();

        for cap in import_re.captures_iter(&content) {
            let import_path = &cap[1];
            if self.is_node_module_import(import_path) {
                // 添加到依赖集合
                file_deps.insert(import_path.to_string());

                if let Some(resolved_path) = self.resolve_module_path(import_path).await {
                    // 将导入路径替换为 /@modules/ 开头的路径
                    let new_path = format!("/@modules/{}", import_path);
                    result = result.replace(&cap[0], &cap[0].replace(import_path, &new_path));

                    // 递归分析依赖的模块
                    if let Ok(dep_content) = async_std::fs::read_to_string(&resolved_path).await {
                        self.process_imports(dep_content, resolved_path.to_str().unwrap_or(""))
                            .await;
                    }
                }
            }
        }

        // 更新全局依赖集合
        if !file_deps.is_empty() {
            println!("File: {} Dependencies:", file_path);
            for dep in &file_deps {
                println!("  - {}", dep);
                self.dependencies.write().insert(dep.clone());
            }
        }

        result
    }

    // 获取收集到的所有依赖
    pub fn get_dependencies(&self) -> HashSet<String> {
        self.dependencies.read().clone()
    }
}

#[async_trait::async_trait]
impl<State: Clone + Send + Sync + 'static> tide::Middleware<State> for NodeModules {
    async fn handle(&self, req: Request<State>, next: Next<'_, State>) -> tide::Result {
        let path = req.url().path();

        // 处理 /@modules/ 开头的请求
        if path.starts_with("/@modules/") {
            let module_path = path.trim_start_matches("/@modules/");
            if let Some(file_path) = self.resolve_module_path(module_path).await {
                if let Ok(content) = async_std::fs::read_to_string(&file_path).await {
                    let mut res = Response::new(StatusCode::Ok);
                    res.set_content_type("application/javascript");
                    // 处理模块文件中的依赖
                    let processed_content = self
                        .process_imports(content, file_path.to_str().unwrap_or(""))
                        .await;
                    res.set_body(processed_content);
                    return Ok(res);
                }
            }
            return Ok(Response::new(StatusCode::NotFound));
        }

        // 处理 .js/.jsx/.ts/.tsx 文件
        if path.ends_with(".js")
            || path.ends_with(".jsx")
            || path.ends_with(".ts")
            || path.ends_with(".tsx")
        {
            let res = next.run(req).await;
            if let Ok(mut response) = res {
                if let Some(body) = response.take_body().into_string().await.ok() {
                    // 处理文件中的导入语句并分析依赖
                    let processed_content = self
                        .process_imports(
                            body,
                            Path::new(&self.root_dir)
                                .join(path.trim_start_matches('/'))
                                .to_str()
                                .unwrap_or(""),
                        )
                        .await;
                    response.set_body(processed_content);
                    return Ok(response);
                }
            }
        }

        Ok(next.run(req).await)
    }
}
